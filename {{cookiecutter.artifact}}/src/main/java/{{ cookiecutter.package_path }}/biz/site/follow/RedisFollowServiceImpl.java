// This project was generated by {{ cookiecutter.author_name }} at {% now 'local', '%Y-%m-%d %X' %}.
// And git commit hash is {% gitcommit %}.

package {{ cookiecutter.basePackage }}.biz.site.follow;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ZSetOperations;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * 使用Redis实现 用户关注业务
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class RedisFollowServiceImpl implements FollowService {

    final StringRedisTemplate stringRedisTemplate;
    private static final String FOLLOWING_KEY = "following:%d";
    private static final String FANS_KEY = "fans:%d";
    private static final String FOLLOWING_CNT_KEY = "following:cnt:%d";
    private static final String FANS_CNT_KEY = "fans:cnt:%d";

    /**
     * 关注用户
     *
     * @param userId   用户ID
     * @param followId 被关注用户ID
     */
    @Override
    public void follow(Integer userId, Integer followId) {
        String key = String.format(FOLLOWING_KEY, userId);
        String key2 = String.format(FANS_KEY, followId);
        String key3 = String.format(FOLLOWING_CNT_KEY, userId);
        String key4 = String.format(FANS_CNT_KEY, followId);

        List<Object> results = stringRedisTemplate.executePipelined(new RedisCallback<Object>() {
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                connection.zAdd(key.getBytes(), Instant.now().getEpochSecond(), followId.toString().getBytes());
                connection.zAdd(key2.getBytes(), Instant.now().getEpochSecond(), userId.toString().getBytes());
                connection.incr(key3.getBytes());
                connection.incr(key4.getBytes());
                return null;
            }
        });
        log.info("follow results: {}", results);
    }

    /**
     * 取消关注
     *
     * @param userId   用户ID
     * @param followId 被关注用户ID
     */
    @Override
    public void unfollow(Integer userId, Integer followId) {
        String key = String.format(FOLLOWING_KEY, userId);
        String key2 = String.format(FANS_KEY, followId);
        String key3 = String.format(FOLLOWING_CNT_KEY, userId);
        String key4 = String.format(FANS_CNT_KEY, followId);

        List<Object> results = stringRedisTemplate.executePipelined(new RedisCallback<Object>() {
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                connection.zRem(key.getBytes(), followId.toString().getBytes());
                connection.zRem(key2.getBytes(), userId.toString().getBytes());
                Long decr1 = connection.decr(key3.getBytes());
                Long decr2 = connection.decr(key4.getBytes());
                if (decr1 == null || decr1 <= 0) {
                    connection.del(key3.getBytes());
                }
                if (decr2 == null || decr2 <= 0) {
                    connection.del(key4.getBytes());
                }
                return null;
            }
        });
        log.info("unfollow results: {}", results);
    }

    /**
     * 获取关注用户ID列列表
     *
     * @param userId   用户ID
     * @param pageNo   页码
     * @param pageSize 分页大小
     * @return 关注用户ID列表
     */
    @Override
    public List<Integer> getFollowing(Integer userId, Integer pageNo, Integer pageSize) {
        int start = (pageNo - 1) * pageSize;
        int stop = start + pageSize - 1;

        String key = String.format(FOLLOWING_KEY, userId);
        return getIntegers(key, start, stop);
    }

    private List<Integer> getIntegers(String key, int start, int stop) {
        Set<ZSetOperations.TypedTuple<String>> tuples = stringRedisTemplate.opsForZSet()
                .reverseRangeWithScores(key, start, stop);
        if (tuples != null && !tuples.isEmpty()) {
            return tuples.stream()
                    .map(t -> Integer.valueOf(Objects.requireNonNull(t.getValue())))
                    .collect(Collectors.toList());
        }

        return Collections.emptyList();
    }

    /**
     * 获取粉丝列表
     *
     * @param userId   用户ID
     * @param pageNo   页码
     * @param pageSize 分页大小
     * @return 粉丝用户ID列表
     */
    @Override
    public List<Integer> getFollowers(Integer userId, Integer pageNo, Integer pageSize) {
        int start = (pageNo - 1) * pageSize;
        int stop = start + pageSize - 1;

        String key = String.format(FANS_KEY, userId);
        return getIntegers(key, start, stop);
    }

    /**
     * 获取关注数
     *
     * @param userId 用户ID
     * @return 关注数
     */
    @Override
    public Long countFollowing(Integer userId) {
        String key = String.format(FOLLOWING_KEY, userId);
        Long count = stringRedisTemplate.opsForZSet().zCard(key);
        return count != null ? count : 0L;
    }

    /**
     * 获取粉丝数
     *
     * @param userId 用户ID
     * @return 粉丝数
     */
    @Override
    public Long countFollowers(Integer userId) {
        String key = String.format(FANS_KEY, userId);
        Long count = stringRedisTemplate.opsForZSet().zCard(key);
        return count != null ? count : 0L;
    }

    /**
     * 判断是否关注
     *
     * @param userId   用户ID
     * @param followId 被关注用户ID
     * @return true - 已关注，false - 未关注
     */
    @Override
    public boolean isFollowing(Integer userId, Integer followId) {
        String key = String.format(FOLLOWING_KEY, userId);
        Double score = stringRedisTemplate.opsForZSet().score(key, followId.toString());
        return score != null;
    }
}
