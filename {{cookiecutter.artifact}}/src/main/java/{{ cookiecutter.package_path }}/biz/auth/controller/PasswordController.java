// This project was generated by {{ cookiecutter.author_name }} at {% now 'local', '%Y-%m-%d %X' %}.
// The version of generator is v{{ cookiecutter._version }}.

package {{ cookiecutter.basePackage }}.biz.auth.controller;

import {{ cookiecutter.basePackage }}.biz.auth.entity.User;
import {{ cookiecutter.basePackage }}.biz.auth.enums.ChangePasswordEnum;
import {{ cookiecutter.basePackage }}.biz.auth.request.password.ChangeByOldRequest;
import {{ cookiecutter.basePackage }}.biz.auth.request.password.ForgetRequest;
import {{ cookiecutter.basePackage }}.biz.auth.request.password.RandomRequest;
import {{ cookiecutter.basePackage }}.biz.auth.response.ResetPasswordResponse;
import {{ cookiecutter.basePackage }}.biz.auth.security.PasswordProperties;
import {{ cookiecutter.basePackage }}.biz.auth.service.IPasswordService;
import {{ cookiecutter.basePackage }}.biz.auth.service.LoginService;
import {{ cookiecutter.basePackage }}.biz.auth.util.PasswordChecker;
import {{ cookiecutter.basePackage }}.biz.sys.util.CaptchaUtil;
import {{ cookiecutter.basePackage }}.common.controller.AuthBaseController;
import {{ cookiecutter.basePackage }}.common.response.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.access.annotation.Secured;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import javax.validation.Valid;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * 密码管理
 */
@RestController
@RequestMapping("/auth/password")
@Slf4j
public class PasswordController extends AuthBaseController {

    PasswordProperties passwordProperties;

    IPasswordService passwordService;

    PasswordEncoder passwordEncoder;

    LoginService loginService;

    @Resource
    StringRedisTemplate stringRedisTemplate;

    public PasswordController(PasswordEncoder passwordEncoder, LoginService loginService, IPasswordService passwordService, PasswordProperties passwordProperties) {
        this.passwordEncoder = passwordEncoder;
        this.loginService = loginService;
        this.passwordService = passwordService;
        this.passwordProperties = passwordProperties;
    }

    /**
     * 使用旧密码方式修改密码
     */
    @PreAuthorize("@ck.hasPermit('auth:password:change')")
    @PostMapping("/change")
    public ApiResponse<Object> change(@Valid @RequestBody ChangeByOldRequest request) {
        User user = getLoggedInUser();

        if (null != user && passwordEncoder.matches(request.getOldPassword(), user.getPwd())) {
            String newEncodedPassword = passwordEncoder.encode(request.getNewPassword());
            boolean isChanged = passwordService.change(user.getId(), newEncodedPassword, ChangePasswordEnum.CHANGE_PASSWORD);
            // 退出当前登录状态
            boolean isLoggedOut = loginService.logout(user.getId());
            return new ApiResponse<>(isChanged && isLoggedOut);
        }

        return new ApiResponse<>("修改密码失败，旧密码可能不正确。", false);
    }

    /**
     * 忘记/找回密码（通过短信或邮件验证码）
     */
    // @PreAuthorize("@ck.hasPermit('auth:password:forget')")
    @PostMapping("/forget")
    public ApiResponse<Object> forget(@Valid @RequestBody ForgetRequest request) {
        String key = "code:" + request.getPrincipal();
        Boolean hasKey = stringRedisTemplate.hasKey(key);
        if (Boolean.FALSE.equals(hasKey)) {
            return new ApiResponse<>("找回密码失败，验证码可能已过期", false);
        }

        Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries(key);
        String code = (String) entries.get("code");
        String principal = (String) entries.get("principal");
        if (null == entries.get("userId")) {
            return new ApiResponse<>("用户不存在", false);
        }
        Long userId = Long.valueOf(String.valueOf(entries.get("userId")));
        if (StringUtils.isNotBlank(code) && request.getCode().equalsIgnoreCase(code)) {
            String newEncodedPassword = passwordEncoder.encode(request.getNewPassword());
            boolean success = passwordService.change(userId, newEncodedPassword, ChangePasswordEnum.FIND_PASSWORD);
            Boolean isDeleted = stringRedisTemplate.delete(key);
            log.info("{} 修改密码成功.", principal);
            return new ApiResponse<>(success && Boolean.TRUE.equals(isDeleted));
        }

        return new ApiResponse<>("找回密码失败，验证码可能错误", false);
    }

    /**
     * 重置密码（支持系统管理员、组管理员重置密码）
     *
     * @param userId 用户ID
     */
    @PreAuthorize("@ck.hasPermit('auth:password:reset')")
    @Secured({"ROLE_admin", "ROLE_group-admin"})
    @PostMapping("/reset")
    public ApiResponse<ResetPasswordResponse> reset(@NotNull Long userId) {
        String rawPassword = CaptchaUtil.randCode(passwordProperties.getMinLength(), passwordProperties.getChars());
        String newEncodedPassword = passwordEncoder.encode(rawPassword);
        boolean success = passwordService.change(userId, newEncodedPassword, ChangePasswordEnum.RESET_PASSWORD);

        if (success) {
            // 退出当前登录状态
            loginService.logout(userId);
            return new ApiResponse<>(new ResetPasswordResponse(rawPassword));
        }
        return new ApiResponse<>("重置密码失败", false);
    }


    /**
     * 密码复杂度计算（0-5分）
     *
     * @param password 待检测密码
     */
    @PreAuthorize("@ck.hasPermit('auth:password:complexity')")
    @GetMapping("/complexity")
    public ApiResponse<Integer> complexity(@NotBlank String password) {
        int score = PasswordChecker.checkPasswordComplexity(password);
        return new ApiResponse<>(score);
    }


    /**
     * 随机生成密码
     */
    @PreAuthorize("@ck.hasPermit('auth:password:random')")
    @GetMapping("/random")
    public ApiResponse<List<String>> random(@Valid RandomRequest request) {
        List<String> list = new ArrayList<>(request.getCount());
        for (int i = 0; i < request.getCount(); i++) {
            String pwd = CaptchaUtil.randCode(request.getLength(), request.getChars());
            list.add(pwd);
        }
        return new ApiResponse<>(list);
    }

}
