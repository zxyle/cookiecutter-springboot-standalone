// This project was generated by {{ cookiecutter.author_name }} at {% now 'local', '%Y-%m-%d %X' %}.
// The version of generator is v{{ cookiecutter._version }}.

package {{ cookiecutter.basePackage }}.biz.auth.controller;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import {{ cookiecutter.basePackage }}.biz.auth.config.AuthUserProperties;
import {{ cookiecutter.basePackage }}.biz.auth.constant.AuthConst;
import {{ cookiecutter.basePackage }}.biz.auth.entity.User;
import {{ cookiecutter.basePackage }}.biz.auth.mapper.UserRoleMapper;
import {{ cookiecutter.basePackage }}.biz.auth.request.user.RegisterRequest;
import {{ cookiecutter.basePackage }}.biz.auth.response.RegisterResponse;
import {{ cookiecutter.basePackage }}.biz.auth.security.LoginUser;
import {{ cookiecutter.basePackage }}.biz.auth.service.IUserRoleService;
import {{ cookiecutter.basePackage }}.biz.auth.service.IUserService;
import {{ cookiecutter.basePackage }}.biz.auth.util.JwtUtil;
import {{ cookiecutter.basePackage }}.common.response.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import javax.validation.Valid;
import javax.validation.constraints.NotBlank;

/**
 * 注册管理
 */
@Slf4j
@RestController
@RequestMapping("/auth/register")
public class RegisterController {

    @Autowired
    AuthUserProperties authUserProperties;

    @Autowired
    UserRoleMapper userRoleMapper;

    IUserRoleService userRoleService;

    IUserService userService;

    PasswordEncoder passwordEncoder;

    @Resource
    StringRedisTemplate stringRedisTemplate;

    AuthenticationManager authenticationManager;

    public RegisterController(IUserService userService, PasswordEncoder passwordEncoder, AuthenticationManager authenticationManager) {
        this.userService = userService;
        this.passwordEncoder = passwordEncoder;
        this.authenticationManager = authenticationManager;
    }

    /**
     * 用户注册
     */
    @PreAuthorize("@ck.hasPermit('auth:user:register')")
    @PostMapping("/")
    public ApiResponse<RegisterResponse> register(@Valid @RequestBody RegisterRequest request) {
        if (isExisted(request.getLoginName(), request.getEmail(), request.getMobile())) {
            return new ApiResponse<>("已被占用", false);
        }

        String key = "code:" + request.getEmail();
        String code = (String) stringRedisTemplate.opsForHash().get(key, "code");
        // 校验是否正确
        if (code != null && code.equalsIgnoreCase(request.getCode())) {
            User user = new User();
            String encodedPassword = passwordEncoder.encode(request.getPassword());
            user.setPwd(encodedPassword);
            user.setEmail(request.getEmail());
            boolean success = userService.save(user);
            Boolean deleted = stringRedisTemplate.delete(key);

            if (success && Boolean.TRUE.equals(deleted)) {
                String token = null;
                log.info("注册成功，用户ID：{}, 主账号: {}", user.getId(), request.getEmail());
                if (authUserProperties.isAutoLogin()) {
                    UsernamePasswordAuthenticationToken authenticationToken =
                            new UsernamePasswordAuthenticationToken("email#" + request.getEmail(), request.getPassword());
                    // AuthenticationManager authenticate进行用户认证
                    Authentication authenticate = authenticationManager.authenticate(authenticationToken);
                    // 注册完成后，自动登录
                    LoginUser loginUser = (LoginUser) authenticate.getPrincipal();
                    String userId = loginUser.getUser().getId().toString();
                    token = JwtUtil.createJWT(userId);
                }
                // 注册成功后，禁用用户
                user.setEnabled(AuthConst.DISABLED);
                userService.updateById(user);

                return new ApiResponse<>(new RegisterResponse(token));
            }
        }

        return new ApiResponse<>("注册失败", false);
    }

    /**
     * 检查用户名占用
     *
     * @param name 用户名
     */
    @PreAuthorize("@ck.hasPermit('auth:user:check')")
    @GetMapping("/check")
    public ApiResponse<Boolean> check(@NotBlank String name) {
        if (isExisted(name, null, null)) {
            return new ApiResponse<>("可以注册");
        }
        return new ApiResponse<>("账号名已经被占用，请更换账号名重试", false);
    }

    /**
     * 随机生成用户名
     */
    @PreAuthorize("@ck.hasPermit('auth:user:random')")
    public void random() {

    }

    /**
     * 检查用户名/邮箱/手机号是否被占用
     *
     * @param name   用户名
     * @param email  邮箱
     * @param mobile 手机号
     * @return true: 被占用 false: 未被占用
     */
    public boolean isExisted(String name, String email, String mobile) {
        QueryWrapper<User> wrapper = new QueryWrapper<>();
        wrapper.eq(StringUtils.isNotBlank(name), "login_name", name);
        wrapper.eq(StringUtils.isNotBlank(email), "email", email);
        wrapper.eq(StringUtils.isNotBlank(mobile), "mobile", mobile);
        int count = userService.count(wrapper);
        return count > 0;
    }
}
