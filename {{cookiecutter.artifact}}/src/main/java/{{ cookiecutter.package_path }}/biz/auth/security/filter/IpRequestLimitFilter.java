// This project was generated by {{ cookiecutter.author_name }} at {% now 'local', '%Y-%m-%d %X' %}.
// The version of generator is v{{ cookiecutter._version }}.

package {{ cookiecutter.basePackage }}.biz.auth.security.filter;

import {{ cookiecutter.basePackage }}.common.util.ResponseUtil;
import com.google.common.util.concurrent.RateLimiter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * IP 请求限流过滤器
 */
@Slf4j
@Component
public class IpRequestLimitFilter extends OncePerRequestFilter {

    // 存储 IP 地址和其对应的 RateLimiter 的映射表
    private Map<String, RateLimiter> limiterMap = new ConcurrentHashMap<>();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String ipAddress = request.getRemoteAddr(); // 获取请求 IP 地址

        // 获取对该 IP 地址的限流器, 限制每秒最多处理 10 个请求
        RateLimiter limiter = limiterMap.computeIfAbsent(ipAddress, k -> RateLimiter.create(10));

        // 尝试获取令牌，如果获取失败则拒绝请求
        if (!limiter.tryAcquire()) {
            log.warn("请求被限流");
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            ResponseUtil.forbidden(response);
            return;
        }

        // 继续执行后续的过滤器或处理器
        filterChain.doFilter(request, response);
    }
}
