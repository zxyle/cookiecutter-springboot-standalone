// This project was generated by {{ cookiecutter.author_name }} at {% now 'local', '%Y-%m-%d %X' %}.
// The version of generator is v{{ cookiecutter._version }}.

package {{ cookiecutter.basePackage }}.config.security;

import {{ cookiecutter.basePackage }}.common.constant.AuthConst;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.Arrays;
import java.util.List;


@Service("ck")
public class CheckPermissionService {

    private final WildcardPermission wildcardPermission = new WildcardPermission();

    @Resource
    StringRedisTemplate stringRedisTemplate;

    /**
     * 检查用户拥有的权限是否包含指定的权限
     *
     * @param permission 权限字符串
     * @return 是否有权限
     */
    public boolean hasPermit(String permission) {
        if (StringUtils.isEmpty(permission)) {
            return false;
        }

        UsernamePasswordAuthenticationToken authentication =
                (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();

        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        Integer userId = loginUser.getUser().getId();
        String key = AuthConst.KEY_PREFIX + userId;
        String value = stringRedisTemplate.opsForValue().get(key);
        if (StringUtils.isBlank(value))
            return false;

        List<String> patterns = Arrays.asList(value.split(AuthConst.DELIMITER));
        return wildcardPermission.isPermit(permission, patterns);
    }
}
