// This project was generated by {{ cookiecutter.author_name }} at {% now 'local', '%Y-%m-%d %X' %}.
// The version of generator is v{{ cookiecutter._version }}.

package {{ cookiecutter.basePackage }};

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class IpUtil {

    public static int calculateSubnetMaskBits(String subnetMask) {
        String[] maskParts = subnetMask.split("\\.");
        int maskBits = 0;
        for (String part : maskParts) {
            int bits = Integer.parseInt(part);
            while (bits > 0) {
                maskBits++;
                bits &= (bits - 1);
            }
        }
        return maskBits;
    }

    public static long ipToLong(String ipAddress) {
        String[] ipAddressInArray = ipAddress.split("\\.");
        long result = 0;
        for (int i = 0; i < ipAddressInArray.length; i++) {
            int power = 3 - i;
            int ip = Integer.parseInt(ipAddressInArray[i]);
            result += ip * Math.pow(256, power);
        }
        return result;
    }

    public static String longToIP(long ipAddress) {
        StringBuilder sb = new StringBuilder(15);
        for (int i = 0; i < 4; i++) {
            sb.insert(0, Long.toString(ipAddress & 0xff));
            if (i < 3) {
                sb.insert(0, '.');
            }
            ipAddress = ipAddress >> 8;
        }
        return sb.toString();
    }

    public static void calculateCIDR(String ip, String subnetMask) {
        int subnetMaskBits = calculateSubnetMaskBits(subnetMask);
        long ipLong = ipToLong(ip);
        long subnetMaskLong = ipToLong(subnetMask);
        long networkAddressLong = ipLong & subnetMaskLong;
        long broadcastAddressLong = networkAddressLong | ~subnetMaskLong;
        long firstAddressLong = networkAddressLong + 1;
        long lastAddressLong = broadcastAddressLong - 1;
        List<String> list = calculateIPList(firstAddressLong, lastAddressLong);
        System.out.println(list);
        String networkAddress = longToIP(networkAddressLong);
        String broadcastAddress = longToIP(broadcastAddressLong);
        String firstAddress = longToIP(firstAddressLong);
        String lastAddress = longToIP(lastAddressLong);
        int numAddresses = (int) (lastAddressLong - firstAddressLong + 1);
        System.out.printf("Network Address: %s\n", networkAddress);
        System.out.printf("Broadcast Address: %s\n", broadcastAddress);
        System.out.printf("First Usable Address: %s\n", firstAddress);
        System.out.printf("Last Usable Address: %s\n", lastAddress);
        System.out.printf("Number of Addresses: %d\n", numAddresses);
    }

    public static List<String> calculateIPList(long firstAddressLong, long lastAddressLong) {
        List<String> ipList = new ArrayList<>();
        for (long i = firstAddressLong; i <= lastAddressLong; i++) {
            String ipAddress = longToIP(i);
            ipList.add(ipAddress);
        }
        return ipList;
    }

    public static String calculateSubnetMask(int subnetMaskBits) {
        int value = 0xffffffff << (32 - subnetMaskBits);
        byte[] bytes = new byte[]{
                (byte) ((value & 0xff000000) >> 24),
                (byte) ((value & 0x00ff0000) >> 16),
                (byte) ((value & 0x0000ff00) >> 8),
                (byte) ((value & 0x000000ff))
        };
        try {
            return InetAddress.getByAddress(bytes).getHostAddress();
        } catch (UnknownHostException e) {
            return null;
        }
    }

    public static List<String> calculateIPList(String cidr) {
        List<String> ipList = new ArrayList<>();

        String[] parts = cidr.split("/");
        String ipAddress = parts[0];
        int prefixLength = Integer.parseInt(parts[1]);

        try {
            InetAddress startInetAddress = InetAddress.getByName(ipAddress);
            byte[] startAddressBytes = startInetAddress.getAddress();
            long startAddress = 0;
            for (byte b : startAddressBytes) {
                startAddress = startAddress << 8 | (b & 0xFF);
            }
            long endAddress = startAddress | ((1L << (32 - prefixLength)) - 1);

            for (long i = startAddress + 1; i <= endAddress - 1; i++) {
                byte[] addressBytes = new byte[]{
                        (byte) (i >> 24),
                        (byte) (i >> 16),
                        (byte) (i >> 8),
                        (byte) i
                };
                InetAddress address = InetAddress.getByAddress(addressBytes);
                ipList.add(address.getHostAddress());
            }
        } catch (Exception e) {
            // handle exception
        }

        return ipList;
    }


    public static boolean in(String ip, List<String> ipList) {
        for (String ipStr : ipList) {
            if (ipStr.equals(ip)) {
                return true;
            }

            if (ipStr.contains("/")) {
                List<String> strings = calculateIPList(ipStr);
                if (strings.contains(ip)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static boolean notIn(String ip, List<String> ipList){
        return !in(ip, ipList);
    }


    public static void main(String[] args) {
        // String ip = "192.168.1.100/24";
        String ip = "10.32.128.0/18";
        String[] parts = ip.split("/");
        String ipAddress = parts[0];
        String subnetMask = calculateSubnetMask(Integer.parseInt(parts[1]));
        // System.out.println(subnetMask);
        calculateCIDR(ipAddress, subnetMask);
        List<String> strings = calculateIPList(ip);
        // System.out.println(strings);

        System.out.println(IpUtil.in("192.168.33.33", Arrays.asList("192.168.33.0/24")));

    }
}
